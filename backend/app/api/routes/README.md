# API Routes

This folder contains FastAPI route modules for the backend API.

## persistent_media.py

Provides endpoints for managing a "persistent folder" of local video files. Key features:

- Set/get/clear the persistent folder path (persisted to `persistent_folder_config.json`).
- Scan the folder recursively for video files and return metadata.
- Stream files from the persistent folder via an ID-based endpoint.
- Uses Pydantic models: `PersistentFolderRequest`, `PersistentFolderResponse`, and `MediaFile`.

Example endpoints:

- `POST /api/persistent-media` — set the persistent folder
- `GET /api/persistent-media` — get current persistent folder info
- `GET /api/persistent-media/files` — list media files in the persistent folder
- `DELETE /api/persistent-media` — clear the persistent folder
- `GET /api/persistent-media/stream/{file_id}` — stream a specific file

## Notes

- The module persists the configured path to `persistent_folder_config.json` in the working directory.
- The route generates file IDs deterministically using a hash of the full path: `persistent-{hash(path)}`.
- Thumbnails and durations are not generated by default but can be added later (e.g., with ffprobe or ffmpeg).

Full source for reference:

```python
"""
Persistent Media Routes
Handles server-side persistent folder configuration for loading local video files
"""
from fastapi import APIRouter, HTTPException, status
from pydantic import BaseModel, Field
from pathlib import Path
from typing import Optional, List
import os
import json
import mimetypes

router = APIRouter(tags=["persistent-media"])

# In-memory storage for the persistent path (you can also use a config file)
_persistent_folder_path: Optional[Path] = None

# Config file to persist across server restarts
CONFIG_FILE = Path("persistent_folder_config.json")


class PersistentFolderRequest(BaseModel):
    """Request model for setting persistent folder"""
    path: str = Field(...,
                      description="Absolute path to the folder containing videos")


class PersistentFolderResponse(BaseModel):
    """Response model for persistent folder info"""
    path: str
    exists: bool
    file_count: int


class MediaFile(BaseModel):
    """Model for a media file"""
    id: str
    title: str
    file_name: str
    file_path: str
    file_size: Optional[int] = None
    media_url: str
    thumbnail_url: Optional[str] = None
    duration: Optional[float] = None


# Load persistent folder from config on startup
def load_persistent_folder():
    """Load persistent folder path from config file"""
    global _persistent_folder_path
    try:
        if CONFIG_FILE.exists():
            data = json.loads(CONFIG_FILE.read_text(encoding="utf-8"))
            path_str = data.get("persistent_folder_path")
            if path_str:
                path = Path(path_str)
                if path.exists() and path.is_dir():
                    _persistent_folder_path = path
                    print(f"[*] Loaded persistent folder: {path}")
    except Exception as e:
        print(f"[!] Failed to load persistent folder config: {e}")


def save_persistent_folder():
    """Save persistent folder path to config file"""
    try:
        data = {
            "persistent_folder_path": str(_persistent_folder_path) if _persistent_folder_path else None
        }
        CONFIG_FILE.write_text(json.dumps(data, indent=2), encoding="utf-8")
    except Exception as e:
        print(f"[!] Failed to save persistent folder config: {e}")


# Load on module import
load_persistent_folder()


def is_video_file(file_path: Path) -> bool:
    """Check if a file is a video based on extension and MIME type"""
    video_extensions = {'.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv',
                        '.webm', '.m4v', '.mpg', '.mpeg', '.3gp', '.ogv'}

    # Check extension
    if file_path.suffix.lower() not in video_extensions:
        return False

    # Double-check with MIME type
    mime_type, _ = mimetypes.guess_type(str(file_path))
    if mime_type and mime_type.startswith('video/'):
        return True

    # If MIME type is unknown but extension matches, accept it
    return True


def scan_folder_for_videos(folder_path: Path) -> List[MediaFile]:
    """
    Recursively scan folder for video files

    Args:
        folder_path: Path to scan

    Returns:
        List of MediaFile objects
    """
    media_files = []

    try:
        # Walk through directory and subdirectories
        for root, dirs, files in os.walk(folder_path):
            for file in files:
                file_path = Path(root) / file

                # Check if it's a video file
                if is_video_file(file_path):
                    try:
                        # Get file size
                        file_size = file_path.stat().st_size

                        # Create a unique ID based on the full path
                        file_id = f"persistent-{hash(str(file_path))}"

                        # Get relative path for display
                        try:
                            rel_path = file_path.relative_to(folder_path)
                        except ValueError:
                            rel_path = file_path.name

                        # Create media URL (we'll serve these via a separate endpoint)
                        # Encode the path to handle special characters
                        encoded_path = str(file_path).replace("\\", "/")

                        media_file = MediaFile(
                            id=file_id,
                            title=str(rel_path),
                            file_name=file_path.name,
                            file_path=str(file_path),
                            file_size=file_size,
                            media_url=f"/api/persistent-media/stream/{file_id}",
                            thumbnail_url=None,  # Could generate thumbnails later
                            duration=None  # Could extract with ffprobe later
                        )

                        media_files.append(media_file)

                    except Exception as e:
                        print(f"[!] Error processing file {file_path}: {e}")
                        continue

    except Exception as e:
        print(f"[!] Error scanning folder {folder_path}: {e}")

    return media_files


@router.post("/persistent-media", response_model=PersistentFolderResponse)
async def set_persistent_folder(request: PersistentFolderRequest):
    """
    Set the persistent folder path

    This folder will be remembered across server restarts and its videos
    will be available for playback.
    """
    global _persistent_folder_path

    try:
        folder_path = Path(request.path)

        # Validate path exists
        if not folder_path.exists():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Folder does not exist: {request.path}"
            )

        # Validate it's a directory
        if not folder_path.is_dir():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Path is not a directory: {request.path}"
            )

        # Check read permissions
        if not os.access(folder_path, os.R_OK):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"No read permission for folder: {request.path}"
            )

        # Scan for videos
        videos = scan_folder_for_videos(folder_path)

        # Set persistent folder
        _persistent_folder_path = folder_path

        # Save to config file
        save_persistent_folder()

        print(
            f"[+] Persistent folder set: {folder_path} ({len(videos)} videos found)")

        return PersistentFolderResponse(
            path=str(folder_path),
            exists=True,
            file_count=len(videos)
        )

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to set persistent folder: {str(e)}"
        )


@router.get("/persistent-media")
async def get_persistent_folder():
    """Get current persistent folder configuration"""
    if _persistent_folder_path is None:
        return {
            "path": None,
            "exists": False,
            "file_count": 0
        }

    exists = _persistent_folder_path.exists()
    file_count = 0

    if exists:
        try:
            videos = scan_folder_for_videos(_persistent_folder_path)
            file_count = len(videos)
        except Exception:
            pass

    return {
        "path": str(_persistent_folder_path),
        "exists": exists,
        "file_count": file_count
    }


@router.get("/persistent-media/files")
async def get_persistent_media_files():
    """
    Get list of all video files in the persistent folder

    Returns:
        List of media files with metadata
    """
    if _persistent_folder_path is None:
        return {"items": []}

    if not _persistent_folder_path.exists():
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Persistent folder no longer exists"
        )

    try:
        videos = scan_folder_for_videos(_persistent_folder_path)
        return {"items": [video.dict() for video in videos]}
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to scan folder: {str(e)}"
        )


@router.delete("/persistent-media")
async def clear_persistent_folder():
    """Clear the persistent folder configuration"""
    global _persistent_folder_path

    _persistent_folder_path = None

    # Clear config file
    try:
        if CONFIG_FILE.exists():
            CONFIG_FILE.unlink()
    except Exception as e:
        print(f"[!] Failed to delete config file: {e}")

    print("[*] Persistent folder cleared")

    return {
        "message": "Persistent folder cleared",
        "path": None
    }


@router.get("/persistent-media/stream/{file_id}")
async def stream_persistent_media(file_id: str):
    """
    Stream a video file from the persistent folder

    This endpoint serves the actual video file for playback
    """
    if _persistent_folder_path is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="No persistent folder configured"
        )

    # Find the file with matching ID
    try:
        videos = scan_folder_for_videos(_persistent_folder_path)

        matching_video = None
        for video in videos:
            if video.id == file_id:
                matching_video = video
                break

        if matching_video is None:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="File not found in persistent folder"
            )

        file_path = Path(matching_video.file_path)

        if not file_path.exists():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="File no longer exists"
            )

        # Import FileResponse for streaming
        from fastapi.responses import FileResponse

        return FileResponse(
            path=str(file_path),
            media_type="video/mp4",  # Browser will handle most video formats
            filename=file_path.name
        )

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to stream file: {str(e)}"
        )

```

--
Generated from `persistent_media.py` for developer reference.
